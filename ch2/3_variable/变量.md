通用的形式:

```go
var name type = expression
```

类型和表达式可以省略一个, 但不能都省略.
- 如果类型省略, 变量的类型将由编译器对初始化表达式进行推断来决定;
- 如果表达式省略, 其初始值则为对应类型的 `0` 值:
    - 对于数字是 `0`
    - 对于 bool 值是 `false`
    - 对于字符串是 `""`
    - 对于接口和引用类型(slice, 指针, map, 通道, 函数)是 `nil`
    - 对于复合成员, 是其所有内部成员的零值

# 1. 短变量声明

```go
name := expression
```

- 在局部变量的声明和初始化中主要使用短变量声明;
- var 声明通常为那些跟初始化表达式类型不一致的局部变量, 或者用于后续才进行赋值以及初始值不重要的情况;

# 2. 指针
变量是存储值的地方, 借助声明创建变量的变量名来区分.

指针的值是一个变量的地址, 一个指针指示值所保存的位置, 不是所有的值都有地址, 但是所有的变量都有.

使用指针, 可以在无须知道变量名的情况下, 间接读取或更新变量的值.

函数返回局部变量的地址是非常安全的

```go
var p = f()

// 调用过程 f() 产生的局部变量 v 即使在调用返回后依然存在, 指针 p 依然引用它
func f() *int {
    v := 1
    return &v
}

// 每次调用 f() 都会返回不同的值
fmt.Println(f() == f())     // false
fmt.Println(*f() == *f())   // true
```

因为一个指针包含变量的地址, 所以传递一个指针参数给函数, 能够让函数更新简介传递的变量值

```go
func incr(p *int) int {
    *p++    // 递增 p 所指向的值, p 自身不变
    return *p
}

v := 1
incr(&v)                // 现在 v = 2
fmt.Println(incr(&v))   // 3
```

# 3. new 函数
与此同时, 还可以使用内置的 new 函数进行变量的创建

```go
name := new(type)
```

只是语法上的便捷

# 4. 变量的声明周期

> 生命周期指的是程序执行过程中变量存在的时间段

包级别变量的生命周期是整个程序的执行时间, 局部变量有一个动态的生命周期: 每次执行声明语句时都会创建一个新的实体, 一直生存到它变得不可访问, 此时它占用的内存会被回收.

编译器可以选择使用堆或者栈来分配空间, 但不是通过 `var` 或者 `new` 关键字来控制

```go
var global *int
func f() {
    var x int       // x 一定使用堆空间, 因为它在 f() 函数返回后还可以从 global 变量访问, 尽管它被声明为一个局部变量
    x = 1           // 这种情况被称为 x 从 f() 中逃逸
    global = &x
}

func g() {
    y := new(int)   // 当 g() 函数返回的时候, 变量 *y 变得不可访问, 因为 y 没有从 g() 中逃逸
    *y = 1
}
```

